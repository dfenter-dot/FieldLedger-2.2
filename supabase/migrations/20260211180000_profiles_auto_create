-- Auto-create public.profiles row on auth.users signup
--
-- Fixes: new "Request Access" signups creating an Auth user but failing to create
-- a corresponding profiles row (which breaks company gating and access status).

-- 1) Trigger function
create or replace function public.handle_new_auth_user()
returns trigger
language plpgsql
security definer
set search_path = public
as $$
begin
  insert into public.profiles (user_id, email, access_status, is_app_owner)
  values (new.id, new.email, 'pending', false)
  on conflict (user_id) do update
    set email = excluded.email;

  return new;
end;
$$;

-- 2) Trigger on auth.users
DO $$
begin
  if exists (select 1 from pg_trigger where tgname = 'on_auth_user_created') then
    drop trigger on_auth_user_created on auth.users;
  end if;
end;
$$;

create trigger on_auth_user_created
after insert on auth.users
for each row execute procedure public.handle_new_auth_user();

-- 3) Basic RLS policies on public.profiles (create if missing)
alter table public.profiles enable row level security;

DO $$
begin
  -- SELECT own profile
  if not exists (
    select 1 from pg_policies
    where schemaname = 'public'
      and tablename = 'profiles'
      and policyname = 'profiles_select_own'
  ) then
    create policy profiles_select_own
      on public.profiles
      for select
      using (user_id = auth.uid());
  end if;

  -- UPDATE own profile
  if not exists (
    select 1 from pg_policies
    where schemaname = 'public'
      and tablename = 'profiles'
      and policyname = 'profiles_update_own'
  ) then
    create policy profiles_update_own
      on public.profiles
      for update
      using (user_id = auth.uid())
      with check (user_id = auth.uid());
  end if;
end;
$$;

